{"ast":null,"code":"import React,{createContext,useContext,useState,useEffect}from'react';import{jsx as _jsx}from\"react/jsx-runtime\";const ClientContext=/*#__PURE__*/createContext(undefined);export const useClient=()=>{const context=useContext(ClientContext);if(context===undefined){throw new Error('useClient must be used within a ClientProvider');}return context;};export const ClientProvider=_ref=>{let{children}=_ref;const[currentClient,setCurrentClient]=useState(null);const[clients,setClients]=useState([]);const[isLoading,setIsLoading]=useState(false);const loadClients=async()=>{setIsLoading(true);try{const response=await fetch('http://localhost:8000/api/clients');const data=await response.json();if(data.success){setClients(data.clients);// If no current client is selected and we have clients, select the first one\nif(!currentClient&&data.clients.length>0){setCurrentClient(data.clients[0]);}}else{console.error('Failed to load clients:',data.error);}}catch(error){console.error('Error loading clients:',error);}finally{setIsLoading(false);}};const createClient=async clientData=>{setIsLoading(true);try{const response=await fetch('http://localhost:8000/api/clients',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(clientData)});const data=await response.json();if(data.success){const newClient=data.client;setClients(prev=>[...prev,newClient]);setCurrentClient(newClient);return newClient;}else{console.error('Failed to create client:',data.error);return null;}}catch(error){console.error('Error creating client:',error);return null;}finally{setIsLoading(false);}};useEffect(()=>{loadClients();},[]);const value={currentClient,clients,setCurrentClient,loadClients,createClient,isLoading};return/*#__PURE__*/_jsx(ClientContext.Provider,{value:value,children:children});};","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","jsx","_jsx","ClientContext","undefined","useClient","context","Error","ClientProvider","_ref","children","currentClient","setCurrentClient","clients","setClients","isLoading","setIsLoading","loadClients","response","fetch","data","json","success","length","console","error","createClient","clientData","method","headers","body","JSON","stringify","newClient","client","prev","value","Provider"],"sources":["C:/Users/shilo/Friedmann-initial-page/frontend/src/contexts/ClientContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\r\n\r\ninterface Client {\r\n  id: string;\r\n  name: string;\r\n  email: string;\r\n  phone?: string;\r\n  age?: number;\r\n  income?: number;\r\n  occupation?: string;\r\n  goals?: string;\r\n  notes?: string;\r\n  created_at: string;\r\n  updated_at: string;\r\n}\r\n\r\ninterface ClientContextType {\r\n  currentClient: Client | null;\r\n  clients: Client[];\r\n  setCurrentClient: (client: Client | null) => void;\r\n  loadClients: () => Promise<void>;\r\n  createClient: (clientData: Partial<Client>) => Promise<Client | null>;\r\n  isLoading: boolean;\r\n}\r\n\r\nconst ClientContext = createContext<ClientContextType | undefined>(undefined);\r\n\r\nexport const useClient = () => {\r\n  const context = useContext(ClientContext);\r\n  if (context === undefined) {\r\n    throw new Error('useClient must be used within a ClientProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\ninterface ClientProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const ClientProvider: React.FC<ClientProviderProps> = ({ children }) => {\r\n  const [currentClient, setCurrentClient] = useState<Client | null>(null);\r\n  const [clients, setClients] = useState<Client[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n\r\n  const loadClients = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n      const response = await fetch('http://localhost:8000/api/clients');\r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        setClients(data.clients);\r\n        // If no current client is selected and we have clients, select the first one\r\n        if (!currentClient && data.clients.length > 0) {\r\n          setCurrentClient(data.clients[0]);\r\n        }\r\n      } else {\r\n        console.error('Failed to load clients:', data.error);\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading clients:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const createClient = async (clientData: Partial<Client>): Promise<Client | null> => {\r\n    setIsLoading(true);\r\n    try {\r\n      const response = await fetch('http://localhost:8000/api/clients', {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(clientData),\r\n      });\r\n      \r\n      const data = await response.json();\r\n      \r\n      if (data.success) {\r\n        const newClient = data.client;\r\n        setClients(prev => [...prev, newClient]);\r\n        setCurrentClient(newClient);\r\n        return newClient;\r\n      } else {\r\n        console.error('Failed to create client:', data.error);\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error creating client:', error);\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  useEffect(() => {\r\n    loadClients();\r\n  }, []);\r\n\r\n  const value: ClientContextType = {\r\n    currentClient,\r\n    clients,\r\n    setCurrentClient,\r\n    loadClients,\r\n    createClient,\r\n    isLoading,\r\n  };\r\n\r\n  return (\r\n    <ClientContext.Provider value={value}>\r\n      {children}\r\n    </ClientContext.Provider>\r\n  );\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}