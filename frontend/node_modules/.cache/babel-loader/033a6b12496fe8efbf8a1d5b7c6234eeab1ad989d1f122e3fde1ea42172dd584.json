{"ast":null,"code":"\"use client\";\n\nvar _s = $RefreshSig$();\nimport { useEffect, useState } from \"react\";\nconst INITIAL_MESSAGE = \"Hello! I'm your financial assistant. I can help you analyze client data, review financial documents, and provide investment guidance. How can I assist you today?\";\nexport default function useFinancialApp() {\n  _s();\n  const initialAssistantMessage = {\n    role: \"assistant\",\n    content: INITIAL_MESSAGE,\n    citations: []\n  };\n  const [messages, setMessages] = useState([initialAssistantMessage]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [indicatorState, setIndicatorState] = useState([]);\n  const [input, setInput] = useState(\"\");\n  const [conversationId, setConversationId] = useState(\"\");\n\n  // Generate conversation ID on mount\n  useEffect(() => {\n    setConversationId(crypto.randomUUID());\n  }, []);\n  const addUserMessage = input => {\n    const newUserMessage = {\n      role: \"user\",\n      content: input,\n      citations: []\n    };\n    setMessages(prevMessages => [...prevMessages, newUserMessage]);\n    return newUserMessage;\n  };\n  const addAssistantMessage = (content, citations) => {\n    const newAssistantMessage = {\n      role: \"assistant\",\n      content,\n      citations\n    };\n    setMessages(prevMessages => [...prevMessages, newAssistantMessage]);\n    return newAssistantMessage;\n  };\n  const fetchAssistantResponse = async allMessages => {\n    const response = await fetch(\"http://localhost:8000/api/chat\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify({\n        message: allMessages[allMessages.length - 1].content,\n        // Send just the last message\n        conversation_id: conversationId\n      })\n    });\n    if (!response.ok) {\n      throw new Error(\"Failed to send message\");\n    }\n    return response;\n  };\n  const handleStreamedMessage = streamedMessage => {\n    setIndicatorState([]);\n    setMessages(prevMessages => {\n      const updatedMessages = [...prevMessages];\n      const lastMessage = updatedMessages[updatedMessages.length - 1];\n      if (lastMessage && lastMessage.role === \"assistant\") {\n        updatedMessages[updatedMessages.length - 1] = {\n          ...lastMessage,\n          content: streamedMessage.message.content,\n          citations: streamedMessage.message.citations\n        };\n      } else {\n        updatedMessages.push({\n          role: \"assistant\",\n          content: streamedMessage.message.content,\n          citations: streamedMessage.message.citations\n        });\n      }\n      return updatedMessages;\n    });\n  };\n  const handleStreamedLoading = streamedLoading => {\n    setIndicatorState(prevIndicatorState => [...prevIndicatorState, streamedLoading.indicator]);\n  };\n  const handleStreamedError = streamedError => {\n    setIndicatorState(prevIndicatorState => [...prevIndicatorState, {\n      ...streamedError.indicator,\n      icon: \"error\"\n    }]);\n  };\n  const processStreamedResponse = async response => {\n    var _response$body;\n    const reader = (_response$body = response.body) === null || _response$body === void 0 ? void 0 : _response$body.getReader();\n    if (!reader) {\n      throw new Error(\"No reader available\");\n    }\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) break;\n      const payload = new TextDecoder().decode(value);\n      const payloads = payload.split(\"\\n\").filter(p => p.trim() !== \"\");\n      for (const payloadLine of payloads) {\n        try {\n          const parsedPayload = JSON.parse(payloadLine);\n          if (parsedPayload.type === \"message\") {\n            handleStreamedMessage(parsedPayload);\n          } else if (parsedPayload.type === \"loading\") {\n            handleStreamedLoading(parsedPayload);\n          } else if (parsedPayload.type === \"error\") {\n            handleStreamedError(parsedPayload);\n          }\n        } catch (e) {\n          console.warn(\"Failed to parse payload:\", payloadLine);\n        }\n      }\n    }\n  };\n  const handleSubmit = async e => {\n    e.preventDefault();\n    if (!input.trim()) return;\n    setIndicatorState([]);\n    setIsLoading(true);\n    setInput(\"\");\n    const newUserMessage = addUserMessage(input);\n    setTimeout(() => {\n      setIndicatorState([{\n        status: \"Analyzing your request\",\n        icon: \"understanding\"\n      }]);\n    }, 600);\n    try {\n      const response = await fetchAssistantResponse([...messages, newUserMessage]);\n      const data = await response.json();\n      if (data.message && data.message.content) {\n        addAssistantMessage(data.message.content, data.message.citations || []);\n      } else {\n        addAssistantMessage(\"I encountered an error processing your request. Please try again.\", []);\n      }\n    } catch (error) {\n      console.error(\"Error:\", error);\n      addAssistantMessage(\"I encountered an error processing your request. Please try again.\", []);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const handleInputChange = e => {\n    setInput(e.target.value);\n  };\n  const clearMessages = () => {\n    setMessages([initialAssistantMessage]);\n    setConversationId(crypto.randomUUID());\n  };\n  return {\n    messages,\n    handleInputChange,\n    handleSubmit,\n    indicatorState,\n    input,\n    isLoading,\n    setMessages,\n    clearMessages,\n    conversationId\n  };\n}\n_s(useFinancialApp, \"6gXVVFi84NIukIG3t1TJriJtG1U=\");","map":{"version":3,"names":["_s","$RefreshSig$","useEffect","useState","INITIAL_MESSAGE","useFinancialApp","initialAssistantMessage","role","content","citations","messages","setMessages","isLoading","setIsLoading","indicatorState","setIndicatorState","input","setInput","conversationId","setConversationId","crypto","randomUUID","addUserMessage","newUserMessage","prevMessages","addAssistantMessage","newAssistantMessage","fetchAssistantResponse","allMessages","response","fetch","method","headers","body","JSON","stringify","message","length","conversation_id","ok","Error","handleStreamedMessage","streamedMessage","updatedMessages","lastMessage","push","handleStreamedLoading","streamedLoading","prevIndicatorState","indicator","handleStreamedError","streamedError","icon","processStreamedResponse","_response$body","reader","getReader","done","value","read","payload","TextDecoder","decode","payloads","split","filter","p","trim","payloadLine","parsedPayload","parse","type","e","console","warn","handleSubmit","preventDefault","setTimeout","status","data","json","error","handleInputChange","target","clearMessages"],"sources":["C:/Users/shilo/Friedmann-initial-page/frontend/src/hooks/useFinancialApp.ts"],"sourcesContent":["\"use client\";\n\nimport { useEffect, useState } from \"react\";\nimport { DisplayMessage, LoadingIndicator, Citation } from \"../types\";\n\nconst INITIAL_MESSAGE = \"Hello! I'm your financial assistant. I can help you analyze client data, review financial documents, and provide investment guidance. How can I assist you today?\";\n\nexport default function useFinancialApp() {\n  const initialAssistantMessage: DisplayMessage = {\n    role: \"assistant\",\n    content: INITIAL_MESSAGE,\n    citations: [],\n  };\n\n  const [messages, setMessages] = useState<DisplayMessage[]>([initialAssistantMessage]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [indicatorState, setIndicatorState] = useState<LoadingIndicator[]>([]);\n  const [input, setInput] = useState(\"\");\n  const [conversationId, setConversationId] = useState<string>(\"\");\n\n  // Generate conversation ID on mount\n  useEffect(() => {\n    setConversationId(crypto.randomUUID());\n  }, []);\n\n  const addUserMessage = (input: string) => {\n    const newUserMessage: DisplayMessage = {\n      role: \"user\",\n      content: input,\n      citations: [],\n    };\n    setMessages((prevMessages) => [...prevMessages, newUserMessage]);\n    return newUserMessage;\n  };\n\n  const addAssistantMessage = (content: string, citations: Citation[]) => {\n    const newAssistantMessage: DisplayMessage = {\n      role: \"assistant\",\n      content,\n      citations,\n    };\n    setMessages((prevMessages) => [...prevMessages, newAssistantMessage]);\n    return newAssistantMessage;\n  };\n\n  const fetchAssistantResponse = async (allMessages: DisplayMessage[]) => {\n    const response = await fetch(\"http://localhost:8000/api/chat\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        message: allMessages[allMessages.length - 1].content, // Send just the last message\n        conversation_id: conversationId\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(\"Failed to send message\");\n    }\n\n    return response;\n  };\n\n  const handleStreamedMessage = (streamedMessage: any) => {\n    setIndicatorState([]);\n    setMessages((prevMessages) => {\n      const updatedMessages = [...prevMessages];\n      const lastMessage = updatedMessages[updatedMessages.length - 1];\n\n      if (lastMessage && lastMessage.role === \"assistant\") {\n        updatedMessages[updatedMessages.length - 1] = {\n          ...lastMessage,\n          content: streamedMessage.message.content,\n          citations: streamedMessage.message.citations,\n        };\n      } else {\n        updatedMessages.push({\n          role: \"assistant\",\n          content: streamedMessage.message.content,\n          citations: streamedMessage.message.citations,\n        });\n      }\n\n      return updatedMessages;\n    });\n  };\n\n  const handleStreamedLoading = (streamedLoading: any) => {\n    setIndicatorState((prevIndicatorState) => [\n      ...prevIndicatorState,\n      streamedLoading.indicator,\n    ]);\n  };\n\n  const handleStreamedError = (streamedError: any) => {\n    setIndicatorState((prevIndicatorState) => [\n      ...prevIndicatorState,\n      { ...streamedError.indicator, icon: \"error\" },\n    ]);\n  };\n\n  const processStreamedResponse = async (response: Response) => {\n    const reader = response.body?.getReader();\n    if (!reader) {\n      throw new Error(\"No reader available\");\n    }\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const payload = new TextDecoder().decode(value);\n      const payloads = payload.split(\"\\n\").filter((p) => p.trim() !== \"\");\n\n      for (const payloadLine of payloads) {\n        try {\n          const parsedPayload = JSON.parse(payloadLine);\n\n          if (parsedPayload.type === \"message\") {\n            handleStreamedMessage(parsedPayload);\n          } else if (parsedPayload.type === \"loading\") {\n            handleStreamedLoading(parsedPayload);\n          } else if (parsedPayload.type === \"error\") {\n            handleStreamedError(parsedPayload);\n          }\n        } catch (e) {\n          console.warn(\"Failed to parse payload:\", payloadLine);\n        }\n      }\n    }\n  };\n\n  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    if (!input.trim()) return;\n    \n    setIndicatorState([]);\n    setIsLoading(true);\n    setInput(\"\");\n    const newUserMessage = addUserMessage(input);\n\n    setTimeout(() => {\n      setIndicatorState([\n        {\n          status: \"Analyzing your request\",\n          icon: \"understanding\",\n        },\n      ]);\n    }, 600);\n\n    try {\n      const response = await fetchAssistantResponse([\n        ...messages,\n        newUserMessage,\n      ]);\n      \n      const data = await response.json();\n      if (data.message && data.message.content) {\n        addAssistantMessage(data.message.content, data.message.citations || []);\n      } else {\n        addAssistantMessage(\"I encountered an error processing your request. Please try again.\", []);\n      }\n    } catch (error) {\n      console.error(\"Error:\", error);\n      addAssistantMessage(\"I encountered an error processing your request. Please try again.\", []);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setInput(e.target.value);\n  };\n\n  const clearMessages = () => {\n    setMessages([initialAssistantMessage]);\n    setConversationId(crypto.randomUUID());\n  };\n\n  return {\n    messages,\n    handleInputChange,\n    handleSubmit,\n    indicatorState,\n    input,\n    isLoading,\n    setMessages,\n    clearMessages,\n    conversationId,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}